From c295e16e8d923e8a2130eed728b7bfcf92183390 Mon Sep 17 00:00:00 2001
From: Paul Zander <negril.nx@gmail.com>
Date: Sat, 31 May 2025 18:52:21 +0200
Subject: [PATCH 17/19] cgal-6

Signed-off-by: Paul Zander <negril.nx@gmail.com>

diff --git a/src/libslic3r/CutSurface.cpp b/src/libslic3r/CutSurface.cpp
index c229ff246..5a5b0674d 100644
--- a/src/libslic3r/CutSurface.cpp
+++ b/src/libslic3r/CutSurface.cpp
@@ -33,6 +33,7 @@ using namespace Slic3r;
 #include <CGAL/Exact_integer.h>
 #include <CGAL/Surface_mesh.h>
 #include <CGAL/Cartesian_converter.h>
+#include <CGAL/AABB_traits_3.h>
 #include <oneapi/tbb/parallel_for.h>
 
 // libslic3r
@@ -1429,8 +1430,8 @@ priv::CutAOIs priv::cut_from_model(CutMesh                &cgal_model,
     // detect anomalities in visitor.
     bool is_valid = true;
     // NOTE: map are created when convert shapes to cgal model
-    const EdgeShapeMap& edge_shape_map = cgal_shape.property_map<EI, IntersectingElement>(edge_shape_map_name).first;
-    const FaceShapeMap& face_shape_map = cgal_shape.property_map<FI, IntersectingElement>(face_shape_map_name).first;
+    const EdgeShapeMap& edge_shape_map = access_pmap(cgal_shape.property_map<EI, IntersectingElement>(edge_shape_map_name));
+    const FaceShapeMap& face_shape_map = access_pmap(cgal_shape.property_map<FI, IntersectingElement>(face_shape_map_name));
     Visitor visitor{cgal_model, cgal_shape, edge_shape_map, face_shape_map, vert_shape_map, &is_valid};
 
     // a property map containing the constrained-or-not status of each edge
@@ -1579,8 +1580,8 @@ void priv::collect_surface_data(std::queue<FI>  &process,
 
 void priv::create_reduce_map(ReductionMap &reduction_map, const CutMesh &mesh)
 {
-    const VertexShapeMap &vert_shape_map = mesh.property_map<VI, const IntersectingElement*>(vert_shape_map_name).first;
-    const EdgeBoolMap &ecm = mesh.property_map<EI, bool>(is_constrained_edge_name).first;
+    const VertexShapeMap &vert_shape_map = access_pmap(mesh.property_map<VI, const IntersectingElement*>(vert_shape_map_name));
+    const EdgeBoolMap &ecm = access_pmap(mesh.property_map<EI, bool>(is_constrained_edge_name));
 
     // check if vertex was made by edge_2 which is diagonal of quad
     auto is_reducible_vertex = [&vert_shape_map](VI reduction_from) -> bool {
@@ -1765,10 +1766,10 @@ priv::VDistances priv::calc_distances(const SurfacePatches &patches,
     for (const SurfacePatch &patch : patches) {
         // map is created during intersection by corefine visitor
         const VertexShapeMap &vert_shape_map = 
-            models[patch.model_id].property_map<VI, const IntersectingElement *>(vert_shape_map_name).first;
+            access_pmap(models[patch.model_id].property_map<VI, const IntersectingElement *>(vert_shape_map_name));
         uint32_t patch_index = &patch - &patches.front();
         // map is created during patch creation / dividing
-        const CvtVI2VI& cvt = patch.mesh.property_map<VI, VI>(patch_source_name).first;
+        const CvtVI2VI& cvt = access_pmap(patch.mesh.property_map<VI, VI>(patch_source_name));
         // for each point on outline
         for (const Loop &loop : patch.loops) 
         for (const VI &vi_patch : loop) {
@@ -2775,7 +2776,7 @@ using BBS = std::vector<BoundingBoxf3>;
 BBS create_bbs(const VCutAOIs &cuts, const CutMeshes &cut_models);
 
 using Primitive = CGAL::AABB_face_graph_triangle_primitive<CutMesh>;
-using Traits    = CGAL::AABB_traits<EpicKernel, Primitive>;
+using Traits    = CGAL::AABB_traits_3<EpicKernel, Primitive>;
 using Ray       = EpicKernel::Ray_3;
 using Tree      = CGAL::AABB_tree<Traits>;
 using Trees     = std::vector<Tree>;
@@ -2929,7 +2930,7 @@ bool priv::is_patch_inside_of_model(const SurfacePatch &patch,
 uint32_t priv::get_shape_point_index(const CutAOI &cut, const CutMesh &model)
 {
     // map is created during intersection by corefine visitor
-    const VertexShapeMap &vert_shape_map = model.property_map<VI, const IntersectingElement *>(vert_shape_map_name).first;
+    const VertexShapeMap &vert_shape_map = access_pmap(model.property_map<VI, const IntersectingElement *>(vert_shape_map_name));
     // for each half edge of outline
     for (HI hi : cut.second) {
         VI vi = model.source(hi);
@@ -2954,7 +2955,7 @@ priv::SurfacePatch priv::separate_patch(const std::vector<FI>& fis,
     patch_new.model_id     = patch.model_id;
     patch_new.shape_id     = patch.shape_id;
     // fix cvt
-    CvtVI2VI cvt = patch_new.mesh.property_map<VI, VI>(patch_source_name).first;
+    CvtVI2VI cvt = access_pmap(patch_new.mesh.property_map<VI, VI>(patch_source_name));
     for (VI &vi : cvt) {
         if (!vi.is_valid()) continue;
         vi = cvt_from[vi];
@@ -2974,7 +2975,7 @@ void priv::divide_patch(size_t i, SurfacePatchesEx &patches)
     std::string patch_number_name = "f:patch_number";
     CutMesh::Property_map<FI,bool> is_processed = access_pmap(cm.add_property_map<FI, bool>(patch_number_name, false));
     
-    const CvtVI2VI& cvt_from = patch.mesh.property_map<VI, VI>(patch_source_name).first;
+    const CvtVI2VI& cvt_from = access_pmap(patch.mesh.property_map<VI, VI>(patch_source_name));
 
     std::vector<FI> fis;
     fis.reserve(cm.faces().size());
@@ -3161,7 +3162,7 @@ bool priv::is_over_whole_expoly(const CutAOI    &cutAOI,
                                 const CutMesh   &mesh)
 {
     // NonInterupted contour is without other point and contain all from shape    
-    const VertexShapeMap &vert_shape_map = mesh.property_map<VI, const IntersectingElement*>(vert_shape_map_name).first;
+    const VertexShapeMap &vert_shape_map = access_pmap(mesh.property_map<VI, const IntersectingElement*>(vert_shape_map_name));
     for (HI hi : cutAOI.second) { 
         const IntersectingElement *ie_s = vert_shape_map[mesh.source(hi)];
         const IntersectingElement *ie_t = vert_shape_map[mesh.target(hi)];
-- 
2.49.0

